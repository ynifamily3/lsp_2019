~/.vimrc 설정하기 수정됨4
set nu
set ts=4
set ruler
set cindent
set autoread
set hls
set autoindent
set shiftwidth=4
set backspace=eol,start,indent
set history=1000
syntax on

함수 프로토 타입과 간단한 설명
5단원 (프로세스)

#include <stdlib.h>
void exit(int status);
void _Exit(int status);

#include <unistd.h>
void _exit(int status);

#include <stdlib.h>
int atexit(void (*__func__) (void));
int on_exit(void (*function)(int, void *), void *arg);
리턴 값 : 성공 시 0, 실패 시 0이 아닌 값

#include <stdlib.h>
char *getenv(const char *name); 
리턴 값 : 성공 시 name으로 주어진 이름에 해당하는 환경 변수 값을 가리키는 포인터, 그런 이름이 없는 경우 NULL
int putenv(char *str); 
리턴 값 : 성공 시 0, 에러 시 0이 아닌 값을 리턴하고 errno 설정

int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);
리턴 값 : 성공 시 0, 에러 시 -1을 리턴하고 errno 설정

#include <setjmp.h>
int setjmp(jmp_buf env);
리턴 값 : 직접 호출된 경우에는 0, longjmp를 통해서 호출 된 경우에는 0이 아닌 값
void longjmp(jmp_buf env, int val);

#include <sys/resource.h>
#include <sys/time.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);
리턴 값 : 성공 시 0, 에러 시 -1을 리턴하고 errno 설정

#include <unistd.h>
#include <sys/types.h>
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
uid_t geteuid(void);
gid_t getgid(void);
gid_t getegid(void);
리턴 값 : 호출한 프로세스의 *** ID

#include <unistd.h>
#include <sys/types.h>
pid_t fork(void);

리턴 값 : 자식 프로세스의 경우 0, 부모 프로세스의 경우 자식의 pid, 에러 시 -1을 리턴하고 errno 설정
errno 종류 : EAGAIN : ea gain. 시스템에서 허용하는 최대 프로세스의 수를 넘음, ENOMEM :  새로운 프로세스를 위한 스왑 공간이 부족함

자식에게 상속되지 않는 프로세스 속성 : fork의 리턴 값, 해당 프로세스 ID들, 부모 프로세스 ID, 자식의 tms_utime, tms_stime, tms_cutime, tms_cstime 값들은 모두 0으로 설정, 부모가 잠근 파일 lock, 아직 발동되지 않은 경보(alarm)들은 자식에서 모두 해제, 자식의 유보 중인 시그널 집합은 비워짐

//
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);

statloc 인자의 종료 상태 값 : 
하위 8bits      상위 8bits
exit()의 인자      0x00  // 자식 프로세스가 exit()을 호출
  0x00       |cd| Signal No.   : cd : core dump 여부 (1비트) // 자식 프로세스가 시그널에 의해 종료
Signal No.        0x7f  // 자식 프로세스가 SIGSTP, SIGSTOP에 의해 잠시 중단

종료 상태를 조사하는 데 쓰이는 매크로
WIFEXITED(status) : 자식 프로세스가 정상적으로 종료되었으면 참
WEXITSTATUS(status) : exit()의 인자에서 하위 8비트 값을 리턴
WIFSIGNALED(status) : 자식 프로세스가 시그널을 받았으나 그것을 처리하지 않아 비정상적으로 종료되었으면 참
WTERMSIG(status) : 시그널 번호를 리턴
WCOREDUMP(status) : 코어 파일이 생성된 경우에 참 값을 리턴
WIFSTOPPED(status) : 자식 프로세스가 현재 중지 상태이면 참
WSTOPSIG(status) : 실행을 일시 중단시킨 시그널 번호를 리턴


#include <unistd.h>
execl, execv, execle, execve(2), execlp, execvp
int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);
int execv(const char *pathname, char *const argv []);
int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */);
int execve(const char *pathname, char *const argv [], char *const envp []);
int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);
int execvp(const char *filename, char *const argv[]);
리턴 값 : 성공 시 리턴하지 않음, 에러 시 -1을 리턴하고 errno 설정

exec 계열 함수를 호출한 프로세스에서 새 프로그램으로 상속되는 특징
tms 값들 (cpu 사용 시간), 프로세스 ID, 부모 프로세스 ID, gid, session ID, 등등..
exec호출 전에 오픈된 fd들은 호출 후에도 그대로 유지되어 사용될 수 있다.


주로 사용되는 종료 상태 체크 ...
if (WIFEXITED(status)) printf("normally terminated. exit status = %d\n", WEXITSTATUS(status));
else if (WIFSIGNALED(status)) printf("abnormal termination by signal %d. %s\n", WTERMSIG(status),
#ifdef WCOREDUMP
WCOREDUMP(status)?"core dumped":"no core"
#else
(char*)NULL
#endif
);
else if (WIFSTOPPED(status)) printf("stopped by signal %d\n", WSTOPSIG(stat));

클록을 알아낼 때
if ((clocktick = sysconf(_SC_CLK_TCK)) < 0 ) ...



#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
int open(const char *pathname, int oflag, mode_t mode);
int open(const char *pathname, int oflag);
리턴 값 : 성공 시 파일 디스크립터, 에러 시 -1을 리턴하고 errno 설정

#include <unistd.h>
int close(int filedes);
리턴 값 : 성공 시 0, 에러 시 -1을 리턴하고 errno 설정

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
int creat(const char *pathname, mode_t mode);
리턴 값 : 성공 시 쓰기전용으로 열린 파일 디스크립터, 에러 시 -1을 리턴하고 errno 설정

#include <sys/types.h>
#include <unistd.h>
off_t lseek(int filedes, off_t offset, int whence);
리턴 값 : 성공 시 새 파일 오프셋, 에러 시 -1을 리턴하고 errno 설정 (현재 위치 확인 활용, fifo확인(errno검사)) 가능

#include <unistd.h>
ssize_t read(int filedes, void *buf, size_t nbytes);
리턴 값 : 성공 시 읽은 바이트 수, 파일의 끝에 도달 한 경우 0, 에러 시 -1을 리턴하고 errno 설정

ssu_employee의 lseek (인덱싱) : 중요 : 캐스팅
if (lseek(fd, (off_t)record_num * sizeof(record), 0) < 0 ) ... lseek의 세번째 인자 0은 SEEK_SET
ssu_employee의 read (캐스팅) : 
if (read(fd, (char *)&record, sizeof(record)) > 0)... 왜? 앞 record가 char형이라서


read 예제 4번 헷갈릴 만하다. 한 번 풀어봐야지

#include <unistd.h>
ssize_t write(int filedes, const void *buf, size_t nbytes);
리턴 값 : 성공 시 기록된 바이트 수, 에러 시 -1을 리턴하고 errno 설정

#include <unistd.h>
ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
리턴 값 : 성공 시 읽은 바이트 수, 파일의 끝에 도달하면 0, 요청한 바이트 수보다 적은 값이 리턴되더라도 에러가 아님, 에러 시 -1을 리턴하고 errno 설정
ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);
리턴 값 : 성공 시 기록된 바이트 수, 쓰여야 할 바이트 수보다 적은 값이 리턴되더라도 에러가 아님, 에러 시 -1을 리턴하고 errno 설정

#include <unistd.h>
int dup(int filedes);
int dup2(int filedes, int filedes2);
리턴 값 : 성공 시 새로운 파일 디스크립터, 에러 시 -1을 리턴하고 errno 설정
리턴될 파일 디스크립터의 값을 미리 지정하고자 할 때는 dup2()를 호출한다.

#include <unistd.h>
int fsync(int filedes);
int fdatasync(int filedes);
리턴 값 : 성공 시 0, 에러 시 -1을 리턴하고 errno 설정

void sync(void);













